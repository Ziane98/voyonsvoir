name: Auto merge PRs

on:
  workflow_run:
    workflows: ["Security Checks"]
    types: [requested, in_progress, completed]

permissions:
  actions: read
  checks: read
  contents: write
  issues: write
  pull-requests: write

jobs:
  automerge:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo
            const run = context.payload.workflow_run
            const action = context.payload.action
            const runUrl = run.html_url
            const runId = run.id
            const allowMerge = run.conclusion === "success"

            const prs = run.pull_requests || []
            if (prs.length === 0) {
              console.log("No PRs for this workflow run")
              return
            }

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms))
            const requiredBaseChecks = ["gitleaks", "trivy", "clamav"]
            const requiredSameRepoChecks = ["codeql", "gitleaks", "trivy", "clamav"]
            const conflictMarker = "<!-- automerge-conflict -->"
            const statusMarker = (stage) => `<!-- automerge-run:${runId}:${stage} -->`
            const mergeMarker = (stage) => `<!-- automerge-merge:${runId}:${stage} -->`

            async function getPr(number) {
              return (await github.rest.pulls.get({ owner, repo, pull_number: number })).data
            }

            async function listComments(number) {
              const { data } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: number,
                per_page: 100
              })
              return data
            }

            async function commentOnce(number, marker, lines) {
              const comments = await listComments(number)
              if (comments.some((comment) => comment.body?.includes(marker))) {
                console.log(`Comment already exists for PR #${number} (${marker})`)
                return false
              }
              const body = [marker, ...lines].join("\n")
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body
              })
              return true
            }

            async function postConflictComment(pr) {
              const lines = [
                "FR: Cette PR a des conflits avec la branche cible. Merci de les resoudre puis de mettre a jour la PR.",
                "EN: This PR has merge conflicts with the base branch. Please resolve them and update the PR."
              ]
              const posted = await commentOnce(pr.number, conflictMarker, lines)
              if (posted) {
                console.log(`Posted conflict comment on PR #${pr.number}`)
              }
            }

            async function getRunJobs(runId) {
              const { data } = await github.rest.actions.listJobsForWorkflowRun({
                owner,
                repo,
                run_id: runId,
                per_page: 100
              })
              return data.jobs || []
            }

            function formatJobSummary(jobs) {
              if (!jobs.length) return ["Jobs: none"]
              return ["Jobs:", ...jobs.map((job) => `- ${job.name}: ${job.conclusion || job.status}`)]
            }

            async function checksPassed(sha, requiredChecks) {
              const { data } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: sha,
                per_page: 100
              })

              const latestByName = new Map()
              for (const run of data.check_runs) {
                if (!requiredChecks.includes(run.name)) continue
                const existing = latestByName.get(run.name)
                const existingTime = existing?.completed_at || existing?.started_at || ""
                const runTime = run.completed_at || run.started_at || ""
                if (!existing || runTime > existingTime) {
                  latestByName.set(run.name, run)
                }
              }

              const missing = requiredChecks.filter(
                (name) => !latestByName.has(name) && name !== "codeql"
              )
              if (missing.length > 0) {
                console.log(`Missing checks: ${missing.join(", ")}`)
                return false
              }
              if (!latestByName.has("codeql") && requiredChecks.includes("codeql")) {
                console.log("CodeQL check missing or not applicable")
              }

              const failed = []
              for (const name of requiredChecks) {
                const run = latestByName.get(name)
                if (!run) continue
                if (
                  name === "codeql" &&
                  run.status === "completed" &&
                  run.conclusion === "skipped"
                ) {
                  continue
                }
                if (run.status !== "completed" || run.conclusion !== "success") {
                  failed.push({
                    name,
                    status: run.status,
                    conclusion: run.conclusion
                  })
                }
              }

              if (failed.length > 0) {
                console.log(
                  `Checks not successful: ${failed
                    .map((run) => `${run.name} (${run.status}/${run.conclusion})`)
                    .join(", ")}`
                )
                return false
              }

              return true
            }

            async function waitForMergeable(number, attempts = 12, delayMs = 5000) {
              let pr
              for (let i = 0; i < attempts; i++) {
                pr = await getPr(number)
                if (pr.merged) {
                  console.log(`PR #${number} already merged`)
                  return pr
                }
                if (pr.mergeable === true && pr.mergeable_state === "clean") {
                  return pr
                }
                console.log(`Waiting... mergeable=${pr.mergeable} state=${pr.mergeable_state}`)
                await sleep(delayMs)
              }
              return pr
            }

            async function tryMerge(number, allowMerge) {
              const pr = await waitForMergeable(number)
              if (!pr || pr.merged) return
              if (pr.mergeable !== true || pr.mergeable_state !== "clean") {
                if (pr.mergeable_state === "dirty") {
                  await postConflictComment(pr)
                }
                console.log(`PR #${number} not mergeable yet`)
                return
              }
              if (!allowMerge) {
                console.log(`Skipping merge for PR #${number}; checks not successful`)
                return
              }

              const isFork = pr.head?.repo?.full_name !== `${owner}/${repo}`
              const requiredChecks = isFork ? requiredBaseChecks : requiredSameRepoChecks
              const ok = await checksPassed(pr.head.sha, requiredChecks)
              if (!ok) return

              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: number,
                  merge_method: "merge"
                })
                console.log(`Merged PR #${number}`)
                await commentOnce(pr.number, mergeMarker("success"), [
                  "FR: Merge automatique reussi.",
                  "EN: Auto-merge succeeded."
                ])
              } catch (error) {
                if (error.status === 405 || error.status === 409) {
                  console.log(`Merge skipped for PR #${number}: ${error.message}`)
                  await commentOnce(pr.number, mergeMarker("skipped"), [
                    `FR: Merge automatique ignore (${error.message}).`,
                    `EN: Auto-merge skipped (${error.message}).`
                  ])
                  return
                }
                throw error
              }
            }

            if (action === "requested" || action === "in_progress") {
              const stage = action
              const lines = [
                `FR: Checks en cours (${stage}).`,
                `EN: Checks are running (${stage}).`,
                `Run: ${runUrl}`
              ]
              for (const pr of prs) {
                await commentOnce(pr.number, statusMarker(stage), lines)
              }
              return
            }

            if (action !== "completed") {
              console.log(`Unsupported action: ${action}`)
              return
            }

            const jobs = await getRunJobs(runId)
            const jobLines = formatJobSummary(jobs)
            const conclusion = run.conclusion || "unknown"

            const statusLines = allowMerge
              ? [
                  `FR: Checks termines avec succes. Tentative de merge automatique.`,
                  `EN: Checks completed successfully. Attempting auto-merge.`,
                  `Run: ${runUrl}`,
                  ...jobLines
                ]
              : [
                  `FR: Checks termines en echec (conclusion: ${conclusion}).`,
                  `EN: Checks completed with failure (conclusion: ${conclusion}).`,
                  `Run: ${runUrl}`,
                  ...jobLines
                ]

            for (const pr of prs) {
              await commentOnce(pr.number, statusMarker(allowMerge ? "success" : "failure"), statusLines)
              await tryMerge(pr.number, allowMerge)
            }
