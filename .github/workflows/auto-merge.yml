name: Auto merge PRs

on:
  workflow_run:
    workflows: ["Security Checks"]
    types: [completed]

permissions:
  checks: read
  contents: write
  issues: write
  pull-requests: write

jobs:
  automerge:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo
            const run = context.payload.workflow_run
            const allowMerge = run.conclusion === "success"
            if (!allowMerge) {
              console.log(`Security checks conclusion: ${run.conclusion}`)
            }

            const prs = run.pull_requests || []
            if (prs.length === 0) {
              console.log("No PRs for this workflow run")
              return
            }

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms))
            const requiredBaseChecks = ["gitleaks", "trivy", "clamav"]
            const requiredSameRepoChecks = ["codeql", "gitleaks", "trivy", "clamav"]
            const conflictMarker = "<!-- automerge-conflict -->"

            async function getPr(number) {
              return (await github.rest.pulls.get({ owner, repo, pull_number: number })).data
            }

            async function hasConflictComment(number) {
              const { data } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: number,
                per_page: 100
              })
              return data.some((comment) => comment.body?.includes(conflictMarker))
            }

            async function postConflictComment(pr) {
              if (await hasConflictComment(pr.number)) {
                console.log(`Conflict comment already exists for PR #${pr.number}`)
                return
              }
              const body = [
                conflictMarker,
                "FR: Cette PR a des conflits avec la branche cible. Merci de les resoudre puis de mettre a jour la PR.",
                "EN: This PR has merge conflicts with the base branch. Please resolve them and update the PR."
              ].join("\n")
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr.number,
                body
              })
              console.log(`Posted conflict comment on PR #${pr.number}`)
            }

            async function checksPassed(sha, requiredChecks) {
              const { data } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: sha,
                per_page: 100
              })

              const latestByName = new Map()
              for (const run of data.check_runs) {
                if (!requiredChecks.includes(run.name)) continue
                const existing = latestByName.get(run.name)
                const existingTime = existing?.completed_at || existing?.started_at || ""
                const runTime = run.completed_at || run.started_at || ""
                if (!existing || runTime > existingTime) {
                  latestByName.set(run.name, run)
                }
              }

              const missing = requiredChecks.filter(
                (name) => !latestByName.has(name) && name !== "codeql"
              )
              if (missing.length > 0) {
                console.log(`Missing checks: ${missing.join(", ")}`)
                return false
              }
              if (!latestByName.has("codeql") && requiredChecks.includes("codeql")) {
                console.log("CodeQL check missing or not applicable")
              }

              const failed = []
              for (const name of requiredChecks) {
                const run = latestByName.get(name)
                if (!run) continue
                if (
                  name === "codeql" &&
                  run.status === "completed" &&
                  run.conclusion === "skipped"
                ) {
                  continue
                }
                if (run.status !== "completed" || run.conclusion !== "success") {
                  failed.push({
                    name,
                    status: run.status,
                    conclusion: run.conclusion
                  })
                }
              }

              if (failed.length > 0) {
                console.log(
                  `Checks not successful: ${failed
                    .map((run) => `${run.name} (${run.status}/${run.conclusion})`)
                    .join(", ")}`
                )
                return false
              }

              return true
            }

            async function waitForMergeable(number, attempts = 12, delayMs = 5000) {
              let pr
              for (let i = 0; i < attempts; i++) {
                pr = await getPr(number)
                if (pr.merged) {
                  console.log(`PR #${number} already merged`)
                  return pr
                }
                if (pr.mergeable === true && pr.mergeable_state === "clean") {
                  return pr
                }
                console.log(`Waiting... mergeable=${pr.mergeable} state=${pr.mergeable_state}`)
                await sleep(delayMs)
              }
              return pr
            }

            async function tryMerge(number, allowMerge) {
              const pr = await waitForMergeable(number)
              if (!pr || pr.merged) return
              if (pr.mergeable !== true || pr.mergeable_state !== "clean") {
                if (pr.mergeable_state === "dirty") {
                  await postConflictComment(pr)
                }
                console.log(`PR #${number} not mergeable yet`)
                return
              }
              if (!allowMerge) {
                console.log(`Skipping merge for PR #${number}; checks not successful`)
                return
              }

              const isFork = pr.head?.repo?.full_name !== `${owner}/${repo}`
              const requiredChecks = isFork ? requiredBaseChecks : requiredSameRepoChecks
              const ok = await checksPassed(pr.head.sha, requiredChecks)
              if (!ok) return

              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: number,
                  merge_method: "merge"
                })
                console.log(`Merged PR #${number}`)
              } catch (error) {
                if (error.status === 405 || error.status === 409) {
                  console.log(`Merge skipped for PR #${number}: ${error.message}`)
                  return
                }
                throw error
              }
            }

            for (const pr of prs) {
              await tryMerge(pr.number, allowMerge)
            }
